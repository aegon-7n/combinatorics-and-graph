# Алгоритмы для графов

Этот проект включает три алгоритма, используемых для решения различных задач на графах. Все алгоритмы ориентированы на поиск кратчайших путей или эффективное управление соединениями между вершинами:

1. **Алгоритм Беллмана-Форда** — для построения кратчайших путей в графах с возможными отрицательными весами рёбер.
2. **Задача "объединить-найти"** (Union-Find) — для эффективного объединения вершин и поиска их принадлежности в графах.
3. **Алгоритм построения кратчайших путей на сети с единичными длинами** — для поиска кратчайших путей в графах, где все рёбра имеют одинаковую длину (единичную).

## Описание алгоритмов

### 1. **Алгоритм Беллмана-Форда**

Этот алгоритм находит кратчайшие пути от исходной вершины ко всем остальным вершинам в графе, даже если рёбра имеют отрицательные веса. Также он способен выявлять отрицательные циклы в графе, что является важным преимуществом по сравнению с другими алгоритмами.

#### Принцип работы:
- Инициализация: расстояния до всех вершин устанавливаются как бесконечность, за исключением исходной вершины.
- Релаксация рёбер: для каждого ребра графа происходит проверка, можно ли улучшить кратчайшее расстояние.
- Повторение: операция расслабления повторяется для всех рёбер графа \( |V| - 1 \) раз, где \( |V| \) — количество вершин в графе.
- Если после этого операция расслабления всё ещё может быть выполнена, значит в графе существует отрицательный цикл.

#### Важные особенности:
- Подходит для графов с отрицательными весами рёбер.
- Может обнаружить отрицательные циклы.

### 2. **Задача "Объединить-найти" (Union-Find)**

Алгоритм "Объединить-найти" используется для эффективного выполнения операций объединения и поиска. Основное применение — в задачах, требующих отслеживания компонент связности в графах или для обработки динамически изменяющихся компонент (например, в задаче о минимальном остовном дереве).

#### Операции:
- **Find**: Найти корень компоненты, к которой принадлежит вершина.
- **Union**: Объединить две компоненты в одну.

#### Оптимизации:
- **Пути сжатия**: При выполнении операции `Find` путь от вершины к корню компоненты сжимаются, что ускоряет последующие операции.
- **Объединение по рангу**: При выполнении операции `Union` компоненты объединяются по меньшему рангу, что поддерживает сбалансированность дерева.

### 3. **Алгоритм построения кратчайших путей на сети с единичными длинами**

Этот алгоритм предназначен для поиска кратчайших путей в графах, где все рёбра имеют одинаковую длину, равную единице. Алгоритм использует метод **поиска в ширину** (BFS), который идеально подходит для таких графов, так как при использовании BFS минимальный путь всегда будет найден первым.

#### Принцип работы:
- Для каждой вершины графа вычисляется минимальное количество рёбер, которые нужно пройти, чтобы попасть из исходной вершины.
- Алгоритм выполняет BFS, начиная с исходной вершины, и обновляет кратчайшие расстояния для всех достижимых вершин.

#### Важные особенности:
- Алгоритм работает за время \( O(V + E) \), где \( V \) — количество вершин, а \( E \) — количество рёбер.
- Идеален для графов с единичными весами рёбер (или одинаковыми весами для всех рёбер).

## Установка и использование

Для использования этих алгоритмов вам нужно иметь Python версии 3.6 и выше. Для установки и запуска кода выполните следующие шаги:

### 1. Клонируйте репозиторий:

```bash
git clone https://github.com/aegon-7n/combinatorics-and-graph.git
```

### 2. Установите pytest

```bash
pip install pytest
```

### 3. Запустите тесты:

Для проверки корректности работы алгоритмов используйте `pytest`. Для этого выполните команду:

```bash
pytest
```

### 4. Запуск алгоритмов:

- **Алгоритм Беллмана-Форда**:
  Вызовите функцию для вычисления кратчайших путей, передав граф и исходную вершину.

- **Задача "Объединить-найти"**:
  Используйте объект класса для объединения и поиска компонент.

- **Алгоритм для сети с единичными длинами**:
  Вызовите функцию BFS для поиска кратчайших путей в графе с единичными рёбрами.

## Пример использования

### 1. **Алгоритм Беллмана-Форда**:

```python
from bellman_ford import bellman_ford

graph = {
    0: [(1, -1), (2, 4)],
    1: [(2, 3), (3, 2), (4, 2)],
    2: [(3, 5)],
    3: [(4, -3)],
    4: []
}
source = 0
distances = bellman_ford(graph, source)
print(distances)
```

### 2. **Задача "Объединить-найти"**:

```python
from union_find import UnionFind

uf = UnionFind(5)
uf.union(0, 1)
uf.union(1, 2)
print(uf.find(0))  # Выведет 2, так как 0 и 2 теперь в одной компоненте
```

### 3. **Алгоритм для сети с единичными длинами**:

```python
from shortest_path import bfs_shortest_paths

graph = {
    0: [1, 2],
    1: [2],
    2: [3],
    3: [4],
    4: []
}
source = 0
distances = bfs_shortest_paths(graph, source)
print(distances)
```

## Примечания

- Алгоритм Беллмана-Форда работает эффективно для графов с отрицательными рёбрами, но имеет большую временную сложность \(O(VE)\), что может быть проблемой для очень больших графов.
- Задача "Объединить-найти" (Union-Find) является основой многих алгоритмов на графах, включая алгоритмы для минимальных остовных деревьев (например, алгоритм Краскала).
- Алгоритм для графов с единичными длинами (BFS) является очень быстрым и эффективным для работы с такими графами.